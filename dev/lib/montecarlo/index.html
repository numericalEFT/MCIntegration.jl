<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Main module · MCIntegration.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://numericaleft.github.io/MCIntegration.jl/lib/montecarlo/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MCIntegration.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>Main module</a></li><li><a class="tocitem" href="../vegasmc/">Markov-chain based Vegas algorithm</a></li><li><a class="tocitem" href="../vegas/">Vegas algorithm</a></li><li><a class="tocitem" href="../mcmc/">Markov-chain Monte Carlo</a></li><li><a class="tocitem" href="../distribution/">Random Variables</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Main module</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Main module</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/numericaleft/MCIntegration.jl/blob/master/docs/src/lib/montecarlo.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Main-module"><a class="docs-heading-anchor" href="#Main-module">Main module</a><a id="Main-module-1"></a><a class="docs-heading-anchor-permalink" href="#Main-module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.Configuration" href="#MCIntegration.Configuration"><code>MCIntegration.Configuration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Configuration{NI,V,P,O,T}

Struct that contains everything needed for MC.</code></pre><p><strong>Parameters</strong></p><ul><li><code>NI</code> : number of integrands</li><li><code>V</code> : type of variables</li><li><code>P</code> : type of user-defined data</li><li><code>O</code> : type of observables </li><li><code>T</code> : type of integrand</li></ul><p><strong>Static parameters</strong></p><ul><li><code>seed</code>: seed to initialize random numebr generator, also serves as the unique pid of the configuration</li><li><code>rng</code>: a MersenneTwister random number generator, seeded by <code>seed</code></li><li><code>userdata</code>: user-defined parameter</li><li><code>var</code>: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.</li></ul><p><strong>integrand properties</strong></p><ul><li><code>neighbor::Vector{Tuple{Int, Int}}</code> : vector of tuples that defines the neighboring integrands. Two neighboring integrands are directly connected in the Markov chain.    e.g., [(1, 2), (2, 3)] means the integrand 1 and 2 are neighbor, and 2 and 3 are neighbor.    The neighbor vector defines a undirected graph showing how the integrands are connected. Please make sure all integrands are connected.  By default, we assume the N integrands are in the increase order, meaning the neighbor will be set to [(N+1, 1), (1, 2), (2, 3), ..., (N-1, N)], where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.  Only highly correlated integrands are not highly correlated should be defined as neighbors. Otherwise, most of the updates between the neighboring integrands will be rejected and wasted.</li><li><code>dof::Vector{Vector{Int}}</code>: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. </li><li><code>observable</code>: observables that is required to calculate the integrands, will be used in the <code>measure</code> function call.   It is either an array of any type with the common operations like +-*/^ defined. </li><li><code>reweight</code>: reweight factors for each integrands. The reweight factor of the normalization diagram is assumed to be 1. Note that you don&#39;t need to explicitly add the normalization diagram. </li><li><code>visited</code>: how many times this integrand is visited by the Markov chain.</li></ul><p><strong>current MC state</strong></p><ul><li><code>step</code>: the number of MC updates performed up to now</li><li><code>norm</code>: the index of the normalization diagram. <code>norm</code> is larger than the index of any user-defined integrands </li><li><code>normalization</code>: the accumulated normalization factor. Physical observable = Configuration.observable/Configuration.normalization.</li><li><code>propose/accept</code>: array to store the proposed and accepted updates for each integrands and variables.   Their shapes are (number of updates X integrand number X max(integrand number, variable number).   The last index will waste some memory, but the dimension is small anyway.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/configuration.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.Configuration-Union{Tuple{}, Tuple{V}} where V" href="#MCIntegration.Configuration-Union{Tuple{}, Tuple{V}} where V"><code>MCIntegration.Configuration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Configuration(;
    var::Union{Variable,AbstractVector,Tuple}=(Continuous(0.0, 1.0),),
    dof::Union{Int,AbstractVector,AbstractMatrix}=[ones(Int, length(var)),],
    type=Float64,  # type of the integrand
    obs::AbstractVector=zeros(type, length(dof)),
    reweight::Vector{Float64}=ones(length(dof) + 1),
    seed::Int=rand(Random.RandomDevice(), 1:1000000),
    neighbor::Union{Vector{Vector{Int}},Vector{Tuple{Int,Int}},Nothing}=nothing,
    userdata=nothing,
    kwargs...
)</code></pre><p>Create a Configuration struct</p><p><strong>Arguments</strong></p><ul><li><code>var</code>: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.</li></ul><p>By default, var = (Continuous(0.0, 1.0),), which is a single continuous variable.</p><ul><li><code>dof::Vector{Vector{Int}}</code>: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. </li></ul><p>By default, dof=[ones(length(var)), ], which means that there is only one integrand, and each variable has one degree of freedom.</p><ul><li><code>obs</code>: observables that is required to calculate the integrands, will be used in the <code>measure</code> function call.</li></ul><p>It is either an array of any type with the common operations like +-*/^ defined.  By default, it will be set to 0.0 if there is only one integrand (e.g., length(dof)==1); otherwise, it will be set to zeros(length(dof)).</p><ul><li><code>para</code>: user-defined parameter, set to nothing if not needed</li><li><code>reweight</code>: reweight factors for each integrands. If not set, then all factors will be initialized with one.</li><li><code>seed</code>: seed to initialize random numebr generator, also serves as the unique pid of the configuration. If it is nothing, then use RandomDevice() to generate a random seed in [1, 1000_1000]</li><li><code>neighbor::Vector{Tuple{Int, Int}}</code> : vector of tuples that defines the neighboring integrands. Two neighboring integrands are directly connected in the Markov chain.    e.g., [(1, 2), (2, 3)] means the integrand 1 and 2 are neighbor, and 2 and 3 are neighbor.     The neighbor vector defines a undirected graph showing how the integrands are connected. Please make sure all integrands are connected.   By default, we assume the N integrands are in the increase order, meaning the neighbor will be set to [(N+1, 1), (1, 2), (2, 4), ..., (N-1, N)], where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.   Only highly correlated integrands are not highly correlated should be defined as neighbors. Otherwise, most of the updates between the neighboring integrands will be rejected and wasted.</li><li><code>userdata</code>: User data you want to pass to the integrand and the measurement</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/configuration.jl#L70-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.Result" href="#MCIntegration.Result"><code>MCIntegration.Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Result{O,C}</code></pre><p>the returned result of the MC integration.</p><p><strong>Members</strong></p><ul><li><code>mean</code>: mean of the MC integration</li><li><code>stdev</code>: standard deviation of the MC integration samples</li><li><code>chi2</code>: reduced chi-square of the MC integration samples</li><li><code>neval</code>: number of evaluations of the integrand</li><li><code>ignore</code>: ignore iterations untill <code>ignore</code></li><li><code>config</code>: configuration of the MC integration from the last iteration</li><li><code>iterations</code>: list of tuples [(data, error, Configuration), ...] from each iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/statistics.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.average" href="#MCIntegration.average"><code>MCIntegration.average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function average(history, idx=1; init=1, max=length(history))</code></pre><p>average the history[1:max]. Return the mean, standard deviation and chi2 of the history.</p><p><strong>Arguments</strong></p><ul><li><code>history</code>: a list of tuples, such as [(data, error, Configuration), ...]</li><li><code>idx</code>: the index of the integral</li><li><code>max</code>: the last index of the history to average with</li><li><code>init</code> : the first index of the history to average with</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/statistics.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.integrate-Tuple{Function}" href="#MCIntegration.integrate-Tuple{Function}"><code>MCIntegration.integrate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate(integrand::Function;
    solver::Symbol=:vegas, # :mcmc, :vegas, or :vegasmc
    config::Union{Configuration,Nothing}=nothing,
    neval=1e4, 
    niter=10, 
    block=16, 
    verbose=-1, 
    gamma=1.0, 
    adapt=true,
    debug=false, 
    reweight_goal::Union{Vector{Float64},Nothing}=nothing, 
    ignore::Int=adapt ? 1 : 0,
    measure::Union{Nothing,Function}=nothing,
    measurefreq::Int=1,
    inplace::Bool=false,
    parallel::Symbol=:nothread,
    kwargs...
)</code></pre><p>Calculate the integrals, collect statistics, and return a Result struct that contains the estimations and errors.</p><p><strong>Remarks</strong></p><ul><li>User may run the MC in parallel using MPI. Simply run <code>mpiexec -n N julia userscript.jl</code> where <code>N</code> is the number of workers. In this mode, only the root process returns meaningful results. All other workers return <code>nothing, nothing</code>. User is responsible to handle the returning results properly. If you have multiple number of mpi version, you can use &quot;mpiexecjl&quot; in your &quot;~/.julia/package/MPI/###/bin&quot; to make sure the version is correct. See https://juliaparallel.github.io/MPI.jl/stable/configuration/ for more detail.</li><li>In the MC, a normalization diagram is introduced to normalize the MC estimates of the integrands. More information can be found in the link: https://kunyuan.github.io/QuantumStatistics.jl/dev/man/important_sampling/#Important-Sampling. User don&#39;t need to explicitly specify this normalization diagram.Internally, normalization diagram will be added to each table that is related to the integrands.</li></ul><p><strong>Arguments</strong></p><ul><li><code>integrand</code>:Function call to evaluate the integrand.               If <code>inplace = false</code>, then the signature of the integrand is <code>integrand(var, config)</code>, where <code>var</code> is a vector of random variables, and <code>config</code> is the <a href="#MCIntegration.Configuration"><code>Configuration</code></a> struct. It should return one or more weights, corresponding to the value of each component of the integrand for the given <code>var</code>.             If <code>inplace = true</code><code>, then the signature of the integrand is</code>integrand(var, weights, config)<code>, where the additional argument</code>weights<code>is the value of the integrand components for the given</code>var`.             Internally, MC only samples the absolute value of the weight. Therefore, it is also important to define Main.abs for the weight if its type is user-defined. </li><li><code>solver</code> :  :vegas, :vegasmc, or :mcmc. See Readme for more details.</li><li><code>config</code>:   <a href="#MCIntegration.Configuration"><code>Configuration</code></a> object to perform the MC integration. If <code>nothing</code>, it attempts to create a new one with Configuration(; kwargs...).</li><li><code>neval</code>:    Number of evaluations of the integrand per iteration. </li><li><code>niter</code>:    Number of iterations. The reweight factor and the variables will be self-adapted after each iteration. </li><li><code>block</code>:    Number of blocks. Each block will be evaluated by about neval/block times. Each block is assumed to be statistically independent, and will be used to estimate the error.              In MPI mode, the blocks are distributed among the workers. If the numebr of workers N is larger than block, then block will be set to be N.</li><li><code>verbose</code>:  &lt; -1 to not print anything; -1 to print minimal information; 0 to print the iteration history in the end; &gt;0 to print MC configuration for every <code>print</code> seconds and print the iteration history in the end.</li><li><code>gamma</code>:    Learning rate of the reweight factor after each iteraction. Note that gamma &lt;=1, where gamma = 0 means no reweighting.  </li><li><code>adapt</code>:    Whether to adapt the grid and the reweight factor.</li><li><code>debug</code>:    Whether to print debug information (type instability, float overflow etc.)</li><li><code>reweight_goal</code>: The expected distribution of visited times for each integrand after reweighting . If not set, then all factors will be initialized with one. Only useful for the :mcmc solver. </li><li><code>ignore</code>:   ignore the iteration until the <code>ignore</code> round. By default, the first iteration is igonred if adapt=true, and non is ignored if adapt=false.</li><li><code>measure</code>:  measurement function, See <a href="../vegas/#MCIntegration.Vegas.montecarlo-Union{Tuple{T}, Tuple{O}, Tuple{P}, Tuple{V}, Tuple{Ni}, Tuple{Configuration{Ni, V, P, O, T}, Function, Any}, Tuple{Configuration{Ni, V, P, O, T}, Function, Any, Any}, Tuple{Configuration{Ni, V, P, O, T}, Function, Any, Any, Any}, Tuple{Configuration{Ni, V, P, O, T}, Function, Vararg{Any, 4}}} where {Ni, V, P, O, T}"><code>Vegas.montecarlo</code></a>, <a href="../vegasmc/#MCIntegration.VegasMC.montecarlo-Union{Tuple{T}, Tuple{O}, Tuple{P}, Tuple{V}, Tuple{N}, Tuple{Configuration{N, V, P, O, T}, Function, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Any, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Any, Any, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Vararg{Any, 4}}} where {N, V, P, O, T}"><code>VegasMC.montecarlo</code></a> and <a href="../mcmc/#MCIntegration.MCMC.montecarlo-Union{Tuple{T}, Tuple{O}, Tuple{P}, Tuple{V}, Tuple{N}, Tuple{Configuration{N, V, P, O, T}, Function, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Any, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Any, Any, Any}, Tuple{Configuration{N, V, P, O, T}, Function, Vararg{Any, 4}}} where {N, V, P, O, T}"><code>MCMC.montecarlo</code></a> for more details.</li><li><code>measurefreq</code>: how often perform the measurement for ever <code>measurefreq</code> MC steps. If a measurement is expansive, you may want to make the measurement less frequent.</li><li><code>inplace</code>:  whether to use the inplace version of the integrand. Default is <code>false</code>, which is more convenient for integrand with a few return values but may cause type instability. Only useful for the :vegas and :vegasmc solver.</li><li><code>parallel</code>: :thread will use Threads.@threads to run different blocks in parallel. Default is :nothread.</li><li><code>kwargs</code>:   Keyword arguments. The supported keywords include,<ul><li><code>measure</code> and <code>measurefreq</code>: measurement function and how frequent it is called. </li><li>If <code>config</code> is <code>nothing</code>, you may need to provide arguments for the <code>Configuration</code> constructor, check <a href="#MCIntegration.Configuration"><code>Configuration</code></a> docs for more details.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">integrate((x, c)-&gt;(x[1]^2+x[2]^2); var = Continuous(0.0, 1.0), dof = 2, verbose=-2, solver=:vegas)
Integral 1 = 0.6663652080622751 ± 0.000490978424216832   (chi2/dof = 0.645)

julia&gt; integrate((x, f, c)-&gt; (f[1] = x[1]^2+x[2]^2); var = Continuous(0.0, 1.0), dof = 2, verbose=-2, solver=:vegas, inplace=true)
Integral 1 = 0.6672083165915914 ± 0.0004919147870306026   (chi2/dof = 2.54)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/main.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MCIntegration.report" href="#MCIntegration.report"><code>MCIntegration.report</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function report(result::Result, ignore=result.ignore; pick::Union{Function,AbstractVector}=obs -&gt; first(obs), name=nothing, verbose=0)</code></pre><p>print the summary of the result.  It will first print the configuration from the last iteration, then print the weighted average and standard deviation of the picked observable from each iteration.</p><p><strong>Arguments</strong></p><ul><li>result: Result object contains the history from each iteration</li><li>ignore: the ignore the first # iteractions.</li><li>pick: The pick function is used to select one of the observable to be printed. The return value of pick function must be a Number.</li><li>name: name of each picked observable. If name is not given, the index of the pick function will be used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericaleft/MCIntegration.jl/blob/464108e3d6bac68b944962a480f5828aae99d2f8/src/statistics.jl#L138-L149">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../vegasmc/">Markov-chain based Vegas algorithm »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 25 July 2023 01:13">Tuesday 25 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
